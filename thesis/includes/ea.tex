\chapter{Evolutionäre Algorithmen}
Im Jahre 1859 veröffentlichte Darwin sein Hauptwerk "`On the Origin of Species"' ("`Über die Entstehung der Arten"') \cite{Darwin:1}, in welchem er die Beobachtung formuliert, dass sich alle Lebewesen in langen Zeiträumen verändern und ihrer Umgebung anpassen. Dieser Prozess basiert laut Darwins These auf den Prozessen der \textit{natürlichen Selektion}. Ernst Mayr fasste Darwins Evolutionstheorie folgendermaßen zusammen \cite{Mayr:1}: 

\begin{enumerate}
	\item Jede Art bringt so viele Nachkommen vor, dass die Population wachsen würde, wenn alle Nachkommen überlebten.
	\item Die Populationsgröße einer Spezies ist langfristig konstant. 
	\item Ressourcen, die die Art für das Überleben benötigt, stehen nur begrenzt, aber über die Zeit in gleichbleibenden Mengen zur Verfügung. 
	\item Daraus folgt ein Kampf ums Überleben. 
	\item Die Individuen einer Population unterscheiden sich deutlich voneinander. 
	\item Die Unterschiede zwischen den Individuen beeinflussen ihre Fähigkeit in ihrer Umwelt zu überleben. 
	\item Individuen, die weniger gut an ihre Umwelt angepasst sind, haben eine geringere Überlebenschance und weniger Nachkommen. Individuen, die besser an ihre Umwelt angepasst sind, haben eine höhere Überlebenschance und mehr Nachkommen.
	\item Die Eigenschaften der Individuen mit einer höheren Überlebenschance verbreiten sich in der Population. Die Eigenschaften der Individuen mit einer geringeren Überlebenschance werden seltener vererbt und fallen damit aus der Population heraus. Dieser Prozess nennt sich natürliche Selektion. Dieser langsam voranschreitende Vorgang führt dazu, dass sich Populationen von Lebewesen sich über lange Zeitabschnitte an die Umwelt anpassen. 
\end{enumerate}

Im folgenden wird Darwins Evolutionstheorie anhand eines Beispiels aus \cite{Rabbits:1} erläutert. Es existiere eine Population von Hasen. Die einzelnen Hasen der Population haben unterschiedliche Eigenschaften: Einige sind schnell, andere sind langsam, manche sind schlau oder dumm. Diese Eigenschaften beeinflussen ihre Fähigkeiten, vor Füchsen (Man nehme an, dass diese auch existieren) zu fliehen. Dumme und langsame Hasen werden zu einer leichten Beute für Füchsen. Schnelle oder schlaue Hasen sind hingegen oft in der Lage, Füchsen zu entkommen, sei es, weil sie entweder schneller sind oder im richtigen Moment einen Haken schlagen, der ihnen einen großen Vorsprung verleiht. Da sie länger überleben oder (im falle des schlauen Hasen) besser Gefahr abschätzen können, sind sie öfter in der Lage, sich mit anderen Hasen zu paaren. Dumme Hasen merken hingegen unter Umständen nicht, dass ein Fuchs auf sie lauert und langsame Hasen entkommen dem Fuchs nicht. Jedoch können auch einige von ihnen überleben, sei es durch Glück. 

Der Teil der Population, der überlebt hat, pflanzt sich nun fort. Dabei entsteht eine gute Mischung an Jungen: Langsame Hasen paaren sich mit schlauen Hasen, schnelle Hasen mit schnellen Hasen, dumme Hasen mit schnellen Hasen, und so weiter. Bei manchen Jungen werden die Eigenschaften, die durch Kombination der Eigenschaften der Eltern entstanden sind, noch mutiert, wodurch ein besonders schlauer, dummer oder schneller Hase erzeugt wird. Die erzeugten Hasenjungen werden durchschnittlich schneller und schlauer sein als die der ursprünglichen Population, da mehr der schlauen und schnellen Hasen der Elterngeneration überlebt haben und sich paaren konnten. Nach einigen Generationen wird dieser Effekt deutlich: Die gesamte Population der Hasen ist schneller und schlauer als die Hasen der ersten Generation. (Man könnte sich nun Sorgen um die Füchse machen, da die meisten Jagdversuche unerfolgreich sind. Jedoch untergehen Sie den gleichen Evolutionsprozess wie die Hasen und werden ebenfalls schneller und schlauer.)

Evolutionäre Algorithmen (\acs{EA}) kopieren das Verfahren der natürlichen Evolution, wobei das Verfahren stark vereinfacht wird. Im Gegenteil zu natürlicher Evolution verfolgen EA jedoch ein spezifisches \textit{Ziel}. Das Ziel ist meistens ein zu lösendes Problem. Der EA erzeugt dafür eine \textit{Population} von Lösungskandidaten. Jeder dieser Kandidaten oder \textit{Individuen} enthält die nötige Information um ihren Lösungsversuch für das Problem zu repräsentieren. Diese Information wird in den meisten Fällen Kodiert in \textit{Genen} gespeichert. Mit einer vom Benutzer erstellen \textit{Fitness-Funktion} kann für jedes Individuum der \textit{Fitness-Wert} - die Qualität des Individuums für das gegebene Problem - bestimmt werden. Für den Paarungsprozess werden zunächst \textit{Eltern} ausgewählt, die in den Paarungs-Pool aufgenommen werden (dieser Schritt nennt sich \textit{Eltern-Selektion}). Aus dem Paarungs-Pool werden zwei Eltern ausgewählt, um \textit{rekombiniert} zu werden. Bei der \textit{Rekombination} wird ein Kind-Individuum erzeugt, das auch einen Lösungskandidat für das Problem repräsentiert. Die Kinder-Individuen stellen die Individuen der \textit{nächsten Generation} dar. Einige Individuen der neuen Generation werden zufällig ausgewählt, um \textit{mutiert} zu werden. In diesem Schritt werden einige Gene des Individuums zufällig geändert, um eine zusätzliche Vielfalt in der Population zu erreichen. Die meisten evolutionären Algorithmen arbeiten mit einer \textit{festen Populationsgröße}. Daher werden im Schritt der \textit{Umwelt-Selektion} die Individuen mit den besten Fitness-Werten aus der Eltern- und der Kind-Generation ausgewählt. Alle anderen Individuen werden entfernt. 

Mit der Zeit haben sich verschiedene Methoden für die Implementierung eines EA entwickelt, um bestimmte Probleme besser lösen zu können. Nur die generelle Struktur des Algorithmus ist meistens die gleiche. % TODO siehe Abbildung 

Im folgenden werden die Terminologie von evolutionären Algorithmen sowie die verschiedenen Verfahren in den Abschnitten von EA vorgestellt. 

\section{Terminologie}
% TODO
% Problem: P
% Fitnessfunktion: f: Ω -> R
% Suchraum des Problems: Ω
% Kodierter Suchraum: X
TODO

\section{Kodierung}
Um ein Optimierungsproblem mit einem \acs{EA} zu lösen, wird meist eine Übersetzung des Suchraums des Problems benötigt. Diese Übersetzung gleicht dem Genotyp-Phaenotyp-Modell aus der Genetik. Der Wert, der im Individuum gespeichert wird, ist der Genotyp. Damit lässt sich mit Hilfe der Kodierung der Phaenotyp berechnen. Der Phaenotyp stellt einen Lösungskandidaten für das Optimierungsproblem bzw. einen Wert aus dem Suchraum des Optimierungsproblem dar. Es muss also ein Alphabet erstellt werden, das durch den Kodierungsprozess einen Wert im Suchraum des Optimierungsproblems darstellt. 

In den frühen zeiten der evolutionären Algorithmen wurde die Genetik der Natur so weit berücksichtigt, dass man

Bei der Wahl der Kodierung sollten einige Grundregeln beachtet werden. Eine davon ist das \textit{Prinzip des minimalen Alphabets} von Goldberg \cite{Golderg:1}: 

\begin{quote}
Der Nutzer sollte das kleinstmögliche Alphabet nutzen, das dem natürlichen Ausdruck des Problems entgegenkommt.
\end{quote}

Es soll also weder ein zu großes, noch ein zu kleines Alphabet verwendet werden. Implmentiert der Nutzer ein zu großes Alphabet, so kann viel Rechenzeit beim Durchforsten zu kleiner und unwichtiger Teilbereiche des Alphabets verloren werden. Ist das Alphabet hingegen zu klein, so kann es sein, dass das Alphabet bestimmte Bereiche des Problems nicht abdeckt. Das ist insbesondere dann für den EA hinderlich, wenn das zu findende Optimum nicht durch das Alphabet dargestellt werden kann. 

Ein weiteres Kriterium für die gute Wahl einer Kodierung ist, dass die Entwicklung von Lösungen möglichst natürlich durch das Alphabet unterstützt wird. Damit wird erreicht, dass nah aneinander liegende Lösungen im Problem auch in ihrer kodierten Form im Individuum Ähnlichkeiten aufweisen. Auch kann dadurch der Rechenaufwand der Kodierung klein gehalten werden. 

\subsection{Binäre Kodierung}
\label{subsec:binary_coding}
In den Anfängen von \acs{EA} wurden fast ausschließlich binäre Kodierungen verwendet \cite{Gerdes:1}. 
Bei der binären Kodierung wird der Lösungsraum des Problems durch einen binären String $b = \mathbb{B}^k = {0, 1}^k$ repräsentiert. Mit mehr oder weniger Aufwand kann jedes Problem mit einer binären Kodierung repräsentiert werden. 

Im folgenden wird beispielhaft ein Problem vorgestellt, das sich sehr leicht mit binärer Kodierung repräsentieren lässt. Man nehme an, man hat einen Raum mit $n$ Lampen $L = \left\{l_1, l_2, \cdots , l_{n-1}, l_n\right\}$ und $n$ Schaltern $S = \left\{s_1, s_2, \cdots , s_{n-1}, s_n\right\}$. Jeder Schalter $s_i$ kann an oder aus sein und bedient damit, ob die Lampe $l_i$ an oder aus ist. Ziel ist, die Helligkeit an einer bestimmten Stelle des Raumes durch das An- und Ausschalten der Schalter auf einen gegebenen Wert zu optimieren. Für die Repräsentation des Problems lässt sich offensichtlich eine binäre Kodierung verwenden: Man nehme einen binären String der Länge $n$. Die $i$-te 0 (oder 1) stellt dar, dass der Schalter $s_i$ an (oder aus) ist. 

Eine weitere Verwendung der binären Kodierung ist die Darstellung vorzeichenloser Integer-Werte. In \ref{eq:binary_to_uint} wird dargestellt, wie die Kodierung eines vorzeichenlosen Integers $x$ mit einer Länge von $l$ Bit in einen binären String $A$ erfolgen kann. Werden für das Problem Integer-Werte mit Vorzeichen benötigt, so kann ein weiteres Bit als Vorzeichenbit verwendet werden. 

\begin{gather}
A = A_1 A_2 \dots A_{n-1} A_n \in \mathbb{B} \nonumber \\
\label{eq:binary_to_uint}
x = \sum\limits_{i=1}^n A_i \cdot 2^{n-i}
\end{gather}

Für viele Probleme werden mehrere Parameter benötigt. Damit eine Folge von Parametern binär kodiert werden kann, muss für jeden Parameter eine feste Länge bekannt sein. Liegt dies vor, können die einzelnen kodierten Werte im binären String aneinandergereiht werden. \ref{eq:multiple_uints} zeigt auf, wie die Kodierung von $m$ vorzeichenlosen Integer-Werten mit je $n$ Bit erfolgen kann. 

\begin{gather}
A = A_1 A_2 \dots A_{m \cdot n-1} A_{m \cdot n} \in \mathbb{B} \nonumber \\
\label{eq:multiple_uints}
x_k = \sum\limits_{i=1}^n A_{n(k-1)+i} \cdot 2^{n-i}
\end{gather}

Werden die Schalter im Beispiel oben durch Dimmer mit $k$ Stufen ausgetauscht, so lässt sich die in \ref{eq:multiple_uints} dargestellte Kodierung verwenden. $m$ ist dabei die Anzahl der Dimmer bzw. Lampen. Die Länge -- also die Anzahl der Bits -- der einzelnen vorzeichenlosen Integerwerte $n$ muss so gewählt werden, dass alle Dimmerstufen $k$ dargestellt werden können ($k \le 2^n$). 

% TODO relle Zahlen?
%Man nehme an, dass die Schalter im Beispiel durch stufenlose Dimmer ausgetauscht werden. Die Dimmer können nun also jeden reellen Zahlenwert zwischen 0 -- zugehörige Lampe ist aus -- und 1 -- zugehörige Lampe leuchtet mit maximaler Helligkeit -- annehmen. Hier wird man allerdings vor ein Problem gestellt: Es gibt unendlich viele reelle Zahlen zwischen 0 und 1. Um die reelle Zahl also exakt binär zu kodieren, muss die binäre Zahl unendlich viele Stellen haben. Dies ist mit einem Computer nicht möglich: Es gibt keinen Computer mit einem Speicher, der unendlich Bits aufnehmen kann. Stattdessen 

\subsection{Kodierung mit Fließkommazahlen}
Man nehme an, die Schalter aus dem Beispiel im Abschnitt \ref{subsec:binary_coding} werden durch stufenlose Dimmer ausgetauscht. Die Dimmer können also jeden reellen Zahlenwert zwischen 0 -- zugehörige Lampe ist aus -- und 1 -- zugehörige Lampe leuchtet mit maximaler Helligkeit -- annehmen. 
Werden die Schalter aus dem Beispiel \ref{subsec:binary_coding} durch stufenlose Dimmer ausgetauscht, 

\section{Fitnessfunktion}
Die Fitnessfunktion oder Zielfunktion bestimmt, wie "`fit"' bzw. wie gut ein Individuum ist und beeinflusst damit direkt die Überlebens- und Fortpflanzungschancen der Individuen. Es handelt sich dabei um  eine Abbildung, die jedem Element des Suchraums des Problems eine reelle Zahl als Bewertung zuweist. Dabei kann selbst entschieden werden, ob das fitteste Individuum den größten oder den kleinsten Fitnesswert haben soll, also, ob der Wert der Fitnessfunktion maximiert oder minimiert werden soll. Für Selektionsverfahren, die die Selektionswahrscheinlichkeit anhand der Fitness der Individuen bestimmen, stellen negative Fitnesswerte ein Problem dar, da auch die Selektionswahrscheinlichkeit negativ wird. Daher ist es üblich, die Fitnessfunktion so zu konstruieren, dass sie auf alle positive reelle Zahlen abbildet:

\begin{equation}
f: \Omega \to \mathbb{R}^+
\end{equation}

Die Fitness eines Individuums ist meistens relativ. Das bedeutet, die Fitness einzelnen Individuums sagt nichts über seine tatsächliche Qualität aus. Mit der Fitness lassen sich lediglich die Individuen unter sich vergleichen. 

% Man betrachte folgendes Beispiel: Es soll die Nullstelle der Funktion $g: \mathbb{R}^n \to \mathbb{R}$ durch einen EA bestimmt werden. Dies lässt sich einfach in ein Minimierungsproblem umwandeln, sodass das Individuum, das am nächsten an einer Nullstelle ist, den kleinsten Fitness-Wert hat. Dafür muss die gegebene Funktion $g$ in der Fitness-Funktion quadriert werden. 

% \begin{equation}
% \label{eq:fitness_example_1}
% f(\mathbf{x}) = g(\mathbf{x})^2, x \in \mathbb{R}^n
% \end{equation}

% Dadurch bewegt sich der Wertebereich von $f$ in $\mathbb{R}_0^+$. Das bedeutet, der kleinste Wert, das globale Minimum von $f$ kann nicht kleiner als $0$ sein. Dieser Wert von $f$ wird genau an der Stelle erreicht, an der $g$ eine Nullstelle hat. Bei einer Suche nach dem globalen Minimum von $f$ wird also nach den Nullstellen von $g$ gesucht.

% Mit der Fitnessfunktion lassen sich viele Probleme beschreiben. Beispielsweise ist es auch möglich, die Nullstelle einer Funktion zu suchen. 

% Der EA ist nur in der Lage, das globale Minimum oder Maximum einer Funktion zu suchen. Um das gegebene Problem P also zu optimieren, muss eine Funktion definiert werden, die das Problem in ein Minimierungs- oder Maximierungsproblem 
% Die Fitnessfunktion oder Zielfunktion bestimmt wie "`fit"' bzw. wie gut ein Individuum ist und beeinflusst damit direkt die Überlebens- und Fortpflanzungschancen der Individuen. Die Fitness eines Individuums wird dabei meist als reelle Zahl angegeben. 

% Die Fitnessfunktion wird dabei so gewählt, dass das zu optimierende Problem in ein Minimierungs- oder Maximierungsproblem umgewandelt wird. Die Mechanismen des EA sind nur in der Lage, das globale Minimum oder das globale Maximum der Fitnessfunktion zu finden. Die Fitnessfunktion ist also die einzige Verbindung des Algorithmus zu dem Problem. 

\section{Selektion}
Stub

\subsection{Plus-Selektion}
Stub

\subsection{Komma-Selektion}
Stub

\subsection{Turnier-Selektion}
Stub

\subsection{Roulette-Selektion}
Stub

\section{Rekombination}

\section{Mutation}
Stub

\section{Elitismus}
Stub

\section{Terminierungskriterien}
Stub






























